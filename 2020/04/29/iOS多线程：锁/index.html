<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础知识,iOS,">










<meta name="description" content="本文主要介绍iOS中常用锁的相关知识及用法，大部分概念来自于线程同步及线程锁。 原子操作问：在OC中对属性变量添加atomic修饰符，能使属性线程安全吗？ 原子操作，即不可分割开的操作；该操作一定是在同一个cpu时间片中完成，这样即使线程被切换，多个线程也不会看到同一块内存中不完整的数据。 原子表示不可分割的最小单元，具体来说是指在所处尺度空间或者层(layer)中不能观测到更为具体的内部实现与结">
<meta name="keywords" content="基础知识,iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 多线程：锁">
<meta property="og:url" content="http://chengweny.github.io/2020/04/29/iOS多线程：锁/index.html">
<meta property="og:site_name" content="YCW&#39;S ZONE">
<meta property="og:description" content="本文主要介绍iOS中常用锁的相关知识及用法，大部分概念来自于线程同步及线程锁。 原子操作问：在OC中对属性变量添加atomic修饰符，能使属性线程安全吗？ 原子操作，即不可分割开的操作；该操作一定是在同一个cpu时间片中完成，这样即使线程被切换，多个线程也不会看到同一块内存中不完整的数据。 原子表示不可分割的最小单元，具体来说是指在所处尺度空间或者层(layer)中不能观测到更为具体的内部实现与结">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-05-05T10:31:55.248Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS 多线程：锁">
<meta name="twitter:description" content="本文主要介绍iOS中常用锁的相关知识及用法，大部分概念来自于线程同步及线程锁。 原子操作问：在OC中对属性变量添加atomic修饰符，能使属性线程安全吗？ 原子操作，即不可分割开的操作；该操作一定是在同一个cpu时间片中完成，这样即使线程被切换，多个线程也不会看到同一块内存中不完整的数据。 原子表示不可分割的最小单元，具体来说是指在所处尺度空间或者层(layer)中不能观测到更为具体的内部实现与结">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chengweny.github.io/2020/04/29/iOS多线程：锁/">





  <title>iOS 多线程：锁 | YCW'S ZONE</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YCW'S ZONE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chengweny.github.io/2020/04/29/iOS多线程：锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CWY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YCW'S ZONE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS 多线程：锁</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-29T14:53:55+08:00">
                2020-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS多线程/" itemprop="url" rel="index">
                    <span itemprop="name">iOS多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文主要介绍iOS中常用锁的相关知识及用法，大部分概念来自于<a href="https://juejin.im/post/5a48c49d518825772a4b53fe#heading-1" target="_blank" rel="noopener">线程同步及线程锁</a>。</p>
<h2 id="原子操作">原子操作</h2><p>问：在OC中对属性变量添加atomic修饰符，能使属性线程安全吗？</p>
<p>原子操作，即不可分割开的操作；该操作一定是在同一个cpu时间片中完成，这样即使线程被切换，多个线程也不会看到同一块内存中不完整的数据。</p>
<p>原子表示不可分割的最小单元，具体来说是指在所处尺度空间或者层(layer)中不能观测到更为具体的内部实现与结构。<strong>对于计算机程序执行的最小单位是单条指令</strong>。我们可以通过参考各种cpu的指令操作手册，用其汇编指令编写原子操作。而这种方式太过于低效。</p>
<p>某些简单的表达式可以算作现代编程语言的最小执行单元,某些简单的表达式，其实编译之后得到的汇编指令不止一条，所以他们并不是真正意义原子的。以加法指令操作实现 x += n为例 ，gcc编译出来的汇编形式上如下：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">movl <span class="number">0</span>xc(<span class="built_in">%ebp</span>), <span class="built_in">%eax</span></span><br><span class="line">addl <span class="built_in">$n</span>, <span class="built_in">%eax</span></span><br><span class="line">movl <span class="built_in">%eax</span>, <span class="number">0</span>xc(<span class="built_in">%ebp</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>而将它放在所线程环境之中，显然也是不安全的：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create()<span class="comment">;</span></span><br><span class="line">    __block int  i = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">for (<span class="name">int</span> k = <span class="number">0</span><span class="comment">; k &lt; 300; k++) &#123;</span></span><br><span class="line">    dispatch_group_enter(<span class="name">group</span>)<span class="comment">;</span></span><br><span class="line">    dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        ++i<span class="comment">;</span></span><br><span class="line">        dispatch_group_leave(<span class="name">group</span>)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    dispatch_group_enter(<span class="name">group</span>)<span class="comment">;</span></span><br><span class="line">    dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        --i<span class="comment">;</span></span><br><span class="line">        dispatch_group_leave(<span class="name">group</span>)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_notify(<span class="name">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"----result=%d  i=%d"</span>,self.pro1,i)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>上述例子中，全局变量i理论上应该最后得到1，而实际上却几率性得到0，-1，2，-2，1。</p>
<p>为了避免错误，很多操作系统或编译器都提供了一些常用原子化操作的内建函数或API，包括一些实际是多条指令的常用表达式。上述操作中，将i++/i–,替换为 OSAtomicIncrement32(&amp;i)  / OSAtomicDecrement32(&amp;i) ，将得到预期的结果1。<br>OC 中的原子操作API </p>
<blockquote>
<p><code>OSAtomicAdd32</code> 原子交换两个值<br><code>OSAtomicDecrement32</code> 原子减少一个值<br><code>OSAtomicIncrement32</code> 原子增加一个值<br><code>OSAtomicXor32</code> 原子进行异或</p>
</blockquote>
<p>综上，OC中使用原子属性，并不能保证线程安全，而iOS中同步锁开销很大，所以在iOS开发中通常给核心业务代码加锁，使其整体变为原子的，而不针对具体的属性读写方法。</p>
<h2 id="iOS中的锁">iOS中的锁</h2><h3 id="互斥锁">互斥锁</h3><h4 id="1-_基本概念">1. 基本概念</h4><p>互斥锁是在很多平台上都比较常用的一种锁。它属于sleep-waiting类型的锁。即当锁处于占用状态时，其他线程会挂起，当锁被释放时，所有等待的线程都将被唤醒，再次对锁进行竞争。在挂起与释放过程中，涉及用户态与内核态之间的context切换，而这种切换是比较消耗性能的。</p>
<h4 id="2-_pthread_mutex">2. pthread_mutex</h4><p>pthread_mutex  是pthread中的互斥锁，具有跨平台性质。pthread是POSIX线程(POSIX threads)的简称，是线程的POSIX标准（可移植操作系统接口 Portable Operation System Interface)。POSIX是unix的api设计标准，兼容各大主流平台。所以pthread_mutex是比较低层的，可以跨平台的互斥锁实现。</p>
<p>初始化方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * __restrict, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * __restrict)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>pthread_mutex_t * __restrict 代表互斥锁的类型，有以下四种：</p>
<blockquote>
<p>1.PTHREAD_MUTEX_NORMAL 缺省类型，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后先进先出原则获得锁。<br>2.PTHREAD_MUTEX_ERRORCHECK 检错锁，如果同一个线程请求同一个锁，则返回 EDEADLK，否则与普通锁类型动作相同。这样就保证当不允许多次加锁时不会出现嵌套情况下的死锁。<br>3.PTHREAD_MUTEX_RECURSIVE 递归锁，允许同一个线程对同一个锁成功获得多次，并通过多次 unlock 解锁。线程首次成功获取互斥锁时，锁定计数会设置为 1。线程每重新锁定该互斥锁一次，锁定计数就增加 1。线程每解除锁定该互斥锁一次，锁定计数就减小 1。 锁定计数达到 0 时，该互斥锁即可供其他线程获取。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。<br>4.PTHREAD_MUTEX_DEFAULT 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争，没有等待队列。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t mutex;</span><br><span class="line"><span class="keyword">void</span> MyInitFunction()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> MyLockingFunction()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="comment">// Do work.</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>pthread_mutex还有一种简便的调用方式，使用的是全局唯一互斥锁。实验表明，该锁是所有属性都是默认的，进程内可见，类型是普通锁</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">block();</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>同时它还提供了一种非阻塞版本pthread_mutex_trylock。若尝试获取锁时发现互斥锁已经被锁定，或则超出了递归锁定的最大次数，则立即返回，不会挂起。只有在锁未被占用时才能成功加锁。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">int</span> res = pthread_mutex_trylock(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span>(res == <span class="number">0</span>)&#123;</span><br><span class="line">    block();</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(res == EBUSY)&#123;</span><br><span class="line">    printf(<span class="string">"由于 mutex 所指向的互斥锁已锁定，因此无法获取该互斥锁。"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (res == EAGAIN)&#123;</span><br><span class="line">    printf(<span class="string">"由于已超出了 mutex 的递归锁定最大次数，因此无法获取该互斥锁。"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-_NSLock、NSRecursiveLock">3. NSLock、NSRecursiveLock</h4><p>官方文档：</p>
<blockquote>
<p>Warning<br>The NSLock class uses POSIX threads to implement its locking behavior. When sending an unlock message to an NSLock object, you must be sure that message is sent from the same thread that sent the initial lock message. Unlocking a lock from a different thread can result in undefined behavior.<br>You should not use this class to implement a recursive lock. Calling the lock method twice on the same thread will lock up your thread permanently. Use the NSRecursiveLock class to implement recursive locks instead.<br>Unlocking a lock that is not locked is considered a programmer error and should be fixed in your code. The NSLock class reports such errors by printing an error message to the console when they occur.</p>
</blockquote>
<ul>
<li>其实现是基于pthread的。</li>
<li>谁持有谁释放，试图释放由其他线程持有的锁是不合法的。</li>
<li>如果用在需要递归嵌套加锁的场景时，需要使用其子类NSRecursiveLock。不是所有情况下都会引发递归调用，而NSLock在性能上要优于NSRecursiveLock。而当我们使用NSLock不小心造成死锁时，可以尝试将其替换为NSRecursiveLock。</li>
<li>lock与unlock是一一对应的，如果试图释放一个没有加锁的锁，会发生异常崩溃。而lock始终等不到对应的unlock会进入饥饿状态，让当前线程一直挂起。</li>
</ul>
<p>使用方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> moreToDo = <span class="literal">YES</span>;</span><br><span class="line"><span class="built_in">NSLock</span> *theLock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span> (moreToDo) &#123;</span><br><span class="line">    <span class="comment">/* Do another increment of calculation */</span></span><br><span class="line">    <span class="comment">/* until there’s no more to do. */</span></span><br><span class="line">    <span class="keyword">if</span> ([theLock tryLock]) &#123;</span><br><span class="line">        <span class="comment">/* Update display used by all threads. */</span></span><br><span class="line">        [theLock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRecursiveLock</span> *theLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> MyRecursiveFunction(<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    [theLock lock];</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --value;</span><br><span class="line">        MyRecursiveFunction(value);</span><br><span class="line">    &#125;</span><br><span class="line">    [theLock unlock];</span><br><span class="line">&#125;</span><br><span class="line">MyRecursiveFunction(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h4 id="4-_@synchronized">4. @synchronized</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myMethod:(<span class="keyword">id</span>)anObj</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(anObj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Everything between the braces is protected by the @synchronized directive.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>anObj 是一个唯一标识符，如果在两个不同线程中执行上述方法，并为anObj参数传递了不同的对象，则每个线程都会获得一个锁继续处理而不会被另一个阻塞，但如果传递相同对象，则其中一个线程会被阻塞，直到第一个线程完成。</p>
<p>@synchronized <a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.mm" target="_blank" rel="noopener">具体源码实现</a> <a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">@synchronized 实现</a></p>
<p>@synchronized块会在受保护的代码中隐式添加一个异常处理程序，如果抛出异常，将自动释放互斥量。这意味着为了使用该指令，还须在代码中启用OC异常处理。<br>隐式添加的代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">    objc_sync_enter(obj);</span><br><span class="line">    <span class="comment">// do work</span></span><br><span class="line">&#125; <span class="keyword">@finally</span> &#123;</span><br><span class="line">    objc_sync_exit(obj);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两个方法的注释</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Begin synchronizing on 'obj'.  </span></span><br><span class="line"><span class="comment"> * Allocates recursive pthread_mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment"> * 为传入的对象分配了一个递归锁，递归锁在同一线程不会引发死锁</span></span><br><span class="line"><span class="comment"> * @param obj The object to begin synchronizing on.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">int</span></span><br><span class="line">objc_sync_enter(<span class="keyword">id</span> _Nonnull obj)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.3</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param obj The object to end synchronizing on.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">int</span></span><br><span class="line">objc_sync_exit(<span class="keyword">id</span> _Nonnull obj)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.3</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    OBJC_SYNC_SUCCESS                 = <span class="number">0</span>,</span><br><span class="line">    OBJC_SYNC_NOT_OWNING_THREAD_ERROR = <span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>加锁代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> objc_sync_enter(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">    <span class="comment">// 可以看做是链表中的一个节点 关联了object与锁</span></span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="keyword">int</span> objc_sync_exit(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表中的一个节点，关联object与lock，并且有一个nextdata指向下一个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SyncData &#123;</span><br><span class="line">    <span class="keyword">id</span> object;</span><br><span class="line">    recursive_mutex_t mutex;</span><br><span class="line">    <span class="keyword">struct</span> SyncData* nextData; </span><br><span class="line">    <span class="keyword">int</span> threadCount; <span class="comment">//此时使用这个锁的线程数量，因为 SyncData 结构体会被缓存，如果threadCount==0 说明这个SyncData实例可以被复用了</span></span><br><span class="line">&#125; SyncData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SyncList &#123;</span><br><span class="line">    SyncData *data;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line">&#125; SyncList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use multiple parallel lists to decrease contention among unrelated objects.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH(obj) ((((uintptr_t)(obj)) &gt;&gt; 5) &amp; (COUNT - 1)) <span class="comment">//哈希算法将对象所在的内存地址转化为无符号整型并右移五位，再跟 0xF 做按位与运算，这样结果不会超出数组大小。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[HASH(obj)].lock</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[HASH(obj)].data</span></span><br><span class="line"><span class="keyword">static</span> SyncList sDataLists[COUNT]; <span class="comment">//声明一个SyncList 结构体数组大小为16</span></span><br></pre></td></tr></table></figure>
<p><code>objc_sync_enter</code>里没有持有传入的对象，假如对象在 “synchronized block” 中被设成 nil时 其他线程使用这个对象会一直阻塞吗？<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number = @(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *thisPtrWillGoToNil = number;</span><br><span class="line"><span class="keyword">@synchronized</span> (thisPtrWillGoToNil) &#123;</span><br><span class="line">    thisPtrWillGoToNil = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>), ^ &#123;</span><br><span class="line">    <span class="built_in">NSCAssert</span>(![<span class="built_in">NSThread</span> isMainThread], <span class="string">@"Must be run on background thread"</span>);</span><br><span class="line">    <span class="keyword">@synchronized</span> (number) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"This line does indeed get printed to stdout"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这行代码还是会打印。OC处理了这种情形，可能是编译器做了如下处理<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *test = <span class="string">@"test"</span>;</span><br><span class="line"><span class="keyword">id</span> synchronizeTarget = (<span class="keyword">id</span>)test;</span><br><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">    objc_sync_enter(synchronizeTarget);</span><br><span class="line">    test = <span class="literal">nil</span>; <span class="comment">//空操作</span></span><br><span class="line">&#125; <span class="keyword">@finally</span> &#123;</span><br><span class="line">    objc_sync_exit(synchronizeTarget);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="自旋锁">自旋锁</h3><p>自旋锁 与互斥锁有点类似，只是自旋锁被某线程占用时，其他线程不会进入睡眠(挂起)状态，而是一直运行（自旋/空转）直到锁被释放。由于不涉及用户态与内核态之间的切换，它的效率远远高于互斥锁。<br>虽然它的效率比互斥锁高，但是它也有些不足之处：</p>
<ul>
<li>自旋锁一直占用CPU，会降低CPU效率。在高并发执行的时候，或代码片段比较耗时，容易引发CPU占用率暴涨的风险</li>
<li>使用自旋锁可能造成死锁，如递归调用时可能会造成死锁</li>
<li><p>自旋锁可能引起优先级反转的问题。如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，自旋锁会处于忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。再iOS10中建议替换OSSPinLock为os_unfair_lock。<br>解决优先级反转有两种方法：优先级天花板和优先级继承</p>
<ol>
<li>优先级天花板是当任务申请锁时，把该任务优先级提升到可访问这个资源的所有任务中的最高优先级。</li>
<li>优先级继承是当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C优先级小于自身优先级，则将任务C的优先级提升到自身优先级。C释放资源后，在恢复C的优先级。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS 10以后使用</span></span><br><span class="line">   os_unfair_lock_t unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"线程1 准备上锁"</span>);</span><br><span class="line">   os_unfair_lock_lock(unfairLock);</span><br><span class="line">   sleep(<span class="number">4</span>);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"线程1"</span>);</span><br><span class="line">   os_unfair_lock_unlock(unfairLock);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"线程1 解锁成功"</span>);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------------"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不在安全的OSSpinLock</a></p>
<h3 id="信号量">信号量</h3><p>dispatch_semaphore是GCD用于控制多线程并发的信号量，通过wait/signal的信号事件控制并发执行的最大线程数，信号量不支持递归.<br>当信号量为0时，dispatch_wait 会阻塞线程，可以利用这点特性实现控制代码块最大并发数，或将异步线程转为同步。</p>
<p>源码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span></span><br><span class="line">dispatch_semaphore_signal(dispatch_semaphore_t dsema)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//对信号量执行+1操作</span></span><br><span class="line">true<span class="keyword">long</span> value = os_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">true<span class="comment">// 如果值大于0 直接返回</span></span><br><span class="line">true<span class="keyword">if</span> (likely(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">if</span> (unlikely(value == LONG_MIN)) &#123;</span><br><span class="line">truetrueDISPATCH_CLIENT_CRASH(value,</span><br><span class="line">truetruetruetrue<span class="string">"Unbalanced call to dispatch_semaphore_signal()"</span>);</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">long</span></span><br><span class="line">_dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema)</span><br><span class="line">&#123;</span><br><span class="line">true_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">true_dispatch_sema4_signal(&amp;dsema-&gt;dsema_sema, <span class="number">1</span>);</span><br><span class="line">true<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span></span><br><span class="line">_dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema,</span><br><span class="line">truetruedispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">true<span class="keyword">long</span> orig;</span><br><span class="line"></span><br><span class="line">true_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">true<span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">true<span class="keyword">default</span>:</span><br><span class="line">truetrue<span class="keyword">if</span> (!_dispatch_sema4_timedwait(&amp;dsema-&gt;dsema_sema, timeout)) &#123;</span><br><span class="line">truetruetrue<span class="keyword">break</span>;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrue<span class="comment">// Fall through and try to undo what the fast path did to</span></span><br><span class="line">truetrue<span class="comment">// dsema-&gt;dsema_value</span></span><br><span class="line">true<span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">truetrueorig = dsema-&gt;dsema_value;</span><br><span class="line">truetrue<span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">truetruetrue<span class="keyword">if</span> (os_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">truetruetruetruetrue&amp;orig, relaxed)) &#123;</span><br><span class="line">truetruetruetrue<span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrue<span class="comment">// Another thread called semaphore_signal().</span></span><br><span class="line">truetrue<span class="comment">// Fall through and drain the wakeup.</span></span><br><span class="line">true<span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">truetrue_dispatch_sema4_wait(&amp;dsema-&gt;dsema_sema);</span><br><span class="line">truetrue<span class="keyword">break</span>;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span></span><br><span class="line">dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 信号量-1</span></span><br><span class="line">true<span class="keyword">long</span> value = os_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">true<span class="comment">// 如果值大于等于0 直接返回</span></span><br><span class="line">true<span class="keyword">if</span> (likely(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="comment">// 否则开始阻塞当前线程</span></span><br><span class="line">true<span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件锁">条件锁</h3><h4 id="1-_NSCondition_条件锁">1. NSCondition 条件锁</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSCondition</span> *cLock = [<span class="built_in">NSCondition</span> new];</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [cLock lock];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程1加锁成功"</span>);</span><br><span class="line">    [cLock wait];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程1"</span>);</span><br><span class="line">    [cLock unlock];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [cLock lock];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程2加锁成功"</span>);</span><br><span class="line">    [cLock wait];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程2"</span>);</span><br><span class="line">    [cLock unlock];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"唤醒一个等待的线程"</span>);</span><br><span class="line">    [cLock signal];</span><br><span class="line">    <span class="comment">//[cLock broadcast] 唤醒所有等待的线程</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">线程<span class="number">1</span>加锁成功</span><br><span class="line">线程<span class="number">2</span>加锁成功</span><br><span class="line">唤醒一个等待的线程</span><br><span class="line">线程<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="2-_NSConditionLock">2. NSConditionLock</h4><p>条件锁，可以用于实现任务间的依赖<br> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">NSConditionLock</span> *cLock = [[<span class="built_in">NSConditionLock</span> alloc] initWithCondition:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">if</span>([cLock tryLockWhenCondition:<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程1"</span>);</span><br><span class="line">       [cLock unlockWithCondition:<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [cLock lockWhenCondition:<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程2"</span>);</span><br><span class="line">    [cLock unlockWithCondition:<span class="number">2</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线程3</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [cLock lockWhenCondition:<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程3"</span>);</span><br><span class="line">    [cLock unlockWithCondition:<span class="number">3</span>];</span><br><span class="line">&#125;);</span><br><span class="line">输出：</span><br><span class="line">线程<span class="number">1</span> </span><br><span class="line">线程<span class="number">3</span></span><br><span class="line">线程<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="读写锁">读写锁</h3><p>读写锁 从广义的逻辑上讲，也可以认为是一种共享版的互斥锁。如果对一个临界区大部分是读操作而只有少量的写操作，读写锁在一定程度上能够降低线程互斥产生的代价。</p>
<p>对于同一个锁，读写锁有两种获取锁的方式：共享(share)方式，独占(Exclusive)方式。写操作独占，读操作共享<br> 读写锁状态 | 以共享方式获取(读操作) | 以独占方式获取(写操作)<br>——-|———|———<br> 自由    | 成功      | 成功<br> 共享    | 成功      | 等待<br> 独占    | 等待      | 等待      </p>
<pre><code class="objc"><span class="comment">//读</span>
    pthread_rwlock_rdlock(&amp;rwLock);
    pthread_rwlock_unlock(&amp;rwLock);
<span class="comment">//写</span>
    pthread_rwlock_wrlock(&amp;rwLock);
    pthread_rwlock_unlock(&amp;rwLock);
</code></pre>
<h2 id="参考">参考</h2><p><a href="https://juejin.im/post/5a48c49d518825772a4b53fe#heading-1" target="_blank" rel="noopener">线程同步及线程锁</a><br><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">关于 @synchronized，这儿比你想知道的还要多</a></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    CWY
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://chengweny.github.io/2020/04/29/iOS多线程：锁/" title="iOS 多线程：锁">http://chengweny.github.io/2020/04/29/iOS多线程：锁/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础知识/" rel="tag"># 基础知识</a>
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/26/NSTimer解决循环引用的几种方式/" rel="next" title="NSTimer解决循环引用的几种方式">
                <i class="fa fa-chevron-left"></i> NSTimer解决循环引用的几种方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/05/iOS多线程：GCD源码分析-一/" rel="prev" title="iOS 多线程：GCD源码分析<一>">
                iOS 多线程：GCD源码分析<一> <i class="fa fa-chevron-right"></i>
              </一></a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CWY">
            
              <p class="site-author-name" itemprop="name">CWY</p>
              <p class="site-description motion-element" itemprop="description">Life is like a box of chocolates. You never know what you're gonna get.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chengwenY" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="y_c_wen@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#原子操作"><span class="nav-number">1.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS中的锁"><span class="nav-number">2.</span> <span class="nav-text">iOS中的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥锁"><span class="nav-number">2.1.</span> <span class="nav-text">互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-_基本概念"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-_pthread_mutex"><span class="nav-number">2.1.2.</span> <span class="nav-text">2. pthread_mutex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-_NSLock、NSRecursiveLock"><span class="nav-number">2.1.3.</span> <span class="nav-text">3. NSLock、NSRecursiveLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-_@synchronized"><span class="nav-number">2.1.4.</span> <span class="nav-text">4. @synchronized</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁"><span class="nav-number">2.2.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量"><span class="nav-number">2.3.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件锁"><span class="nav-number">2.4.</span> <span class="nav-text">条件锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-_NSCondition_条件锁"><span class="nav-number">2.4.1.</span> <span class="nav-text">1. NSCondition 条件锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-_NSConditionLock"><span class="nav-number">2.4.2.</span> <span class="nav-text">2. NSConditionLock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁"><span class="nav-number">2.5.</span> <span class="nav-text">读写锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CWY</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
